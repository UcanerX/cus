#线程池维护线程的最少数量
taskExecutor.corePoolSize = 15
#线程池维护线程所允许的空闲时间
taskExecutor.keepAliveSeconds = 60
#线程池维护线程的最大数量
taskExecutor.maxPoolSize = 200
#线程池所使用的缓冲队列
taskExecutor.queueCapacity = 500

#################################################################################################################
#cron的表达式是字符串，实际上是由七子表达式，描述个别细节的时间表。这些子表达式是分开的空白，代表：
#Cron表达式的格式：秒 分 时 日 月 周 年(可选)
#1.Seconds                 可以用数字0－59 表示
#2.Minutes                 可以用数字0－59 表示
#3.Hours                   可以用数字0-23表示
#4.Day-of-Month            可以用数字1-31 中的任一一个值
#5.Month                   可以用0-11 或用字符串  JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV , DEC表示
#6.Day-of-Week             可以用数字1-7表示（1 ＝ 星期日）或用字符串SUN, MON, TUE, WED, THU, FRI , SAT表示
#7.Year (可选字段) 
#*：任意
#?：表示不确定的值
#,：指定数个值
#-：指定一个值的范围
#/：为特别单位，表示为每 ,如0/15表示每隔15分钟执行一次,0表示为从0分开始, 3/20表示表示每隔20分钟执行一次,3表示从第3分钟开始执行
#?：表示每月的某一天,或第周的某一天
#L：用于每月,或每周,表示为每月的最后一天,或每个月的最后星期几如6L表示每月的最后一个星期五
#W：表示为最近工作日,如15W放在每月(day-of-month)字段上表示为到本月15日最近的工作日
##：是用来指定的,每月第n个工作日,例 在每周(day-of-week)这个字段中内容为"6#3" or "FRI#3" 则表示每月第三个星期五
#例：
#   每隔5秒执行一次：*/5 * * * * ?
#   每隔1分钟执行一次：0 */1 * * * ?
#   每天23点执行一次：0 0 23 * * ?
#   每天凌晨1点执行一次：0 0 1 * * ?
#   每月1号凌晨1点执行一次：0 0 1 1 * ?
#   每月最后一天23点执行一次：0 0 23 L * ?
#   每周星期天凌晨1点实行一次：0 0 1 ? * L
#   在26分、29分、33分执行一次：0 26,29,33 * * * ?
#   每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?
###################################################################################################################
#医院基础信息 科室采集时间设置(每1小时执行一次)
task.biz.cron.deptInfo = 0 */3 * * * ?

#医院基础信息 医生采集时间设置(每1小时执行一次)
task.biz.cron.doctorInfo = 0 */4 * * * ?

#医院号源信息轮询 时间设置(每5分钟执行一次)
task.biz.cron.regSource = 0 */5 * * * ?

#医院挂号解锁轮询 时间设置(每1分钟执行一次)
task.biz.cron.regUnlock = 0 */1 * * * ?

#医院挂号超时轮询 时间设置(每 10秒执行一次)
task.biz.cron.regPayTimeOut = */10 * * * * ?

#停诊号源信息轮询(每天的0点、6点、12点、18点、21点都执行一次)
#task.biz.cron.stopReg = 0 0 0,6,12,18,22 * * ?
#停诊号源信息轮询(每天的8点、10点、13点、20点都执行一次)
task.biz.cron.stopReg = 0 0 8,10,13,20 * * ?
#停诊号源信息轮询(每半小时一次)
#task.biz.cron.stopReg = 0 */3 * * * ?
#停诊时间间隔
#task.biz.stopReg.loop.time = 3600000
task.biz.stopReg.loop.time = 180000
#异常挂号轮询 时间设置(每1分钟执行一次)
task.biz.cron.handleRegException = 0 */1 * * * ?

#门诊缴费异常轮询 时间设置(每1分钟执行一次)
task.biz.cron.handleClinicException = 0 */1 * * * ?
#押金补缴异常轮询 时间设置(每1分钟执行一次)
task.biz.cron.handleDepositException = 0 */1 * * * ?
#出院结算异常轮询 时间设置(每1分钟执行一次)
task.biz.cron.handleSettlementException = 0 */1 * * * ?
#统计任务 每天0点开始执行
task.biz.cron.statistcalTask = 59 59 23 * * ?
#定时获取accessToken(每隔60分钟执行一次)
task.biz.cron.accessToken=0 0 */1 * * ?

#就诊前一天的就诊消息轮询推送(每天的20点执行一次)
task.biz.cron.preDayVisitWarn = 0 */2 * * * ?
#就诊当天的的就诊消息轮序推送(每天的7点执行一次)
task.biz.cron.curDayVisitWarn =0 0 7 * * ?

#就诊前一天晚上八点后到当天晚上八点前的先诊后付支付成功的订单推送(每天的20点执行一次)
task.biz.cron.freeSecretPaymentWarn = 0 0 20 * * ?

#每天凌晨开始医保签到更新更新mackey及更新日期
task.biz.cron.medicareUpdateMacKey = 5 0 0 * * ?
#task.biz.cron.medicareUpdateMacKey = */30 * * * * ?

#就诊当天早上5点自动报到取号
task.biz.cron.offerRegNumber =0 0 2,4,6 * * ?

#排队候诊消息推送任务  每3分钟执行一次
task.biz.cron.waitingMsgPush=0 */3 * * * ?

#每天晚上1点整同步数据(每天的1点执行一次)
task.biz.cron.curDayFinanceWarn =0 09 17 * * ?

#邀请码基础数据采集
task.biz.cron.invitationCode = 0 0 5 * * ?

#邀请码待更新数据采集
task.biz.cron.invitationCodeUpdate =0 30 5 * * ?

#挂号撤销险推送任务 每5分钟执行一次
task.biz.cron.registerRevokeInsure =0 */5 * * * ?



############################################# 系统采集任务 #######################################
#kafka连接地址 集群用,隔开
kafka.bootstrap.servers =192.168.200.224:9092,192.168.200.225:9092
#consumer的组id
kafka.consumer.group.id=sunshine-log
#主题名称 多个用,隔开
kafka.topics=sunshine-topic
#是否自动提交offset
kafka.enable.auto.commit=false
#自动提交的间隔毫秒
kafka.auto.commit.interval.ms=1000
#连接超时时间
kafka.session.timeout.ms=600000
#key反序列化类
kafka.key.deserializer=org.apache.kafka.common.serialization.StringDeserializer
#value反序列化类
kafka.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
#每次获取的消息数
kafka.consumer.poll.num=100
#topic的分区数
kafka.consumer.partition.num=3